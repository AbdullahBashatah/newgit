{"version":3,"file":"parchment.js","mappings":"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","sources":["webpack://Parchment/webpack/universalModuleDefinition","webpack://Parchment/webpack/bootstrap","webpack://Parchment/./src/scope.ts","webpack://Parchment/webpack/runtime/define property getters","webpack://Parchment/webpack/runtime/hasOwnProperty shorthand","webpack://Parchment/webpack/runtime/make namespace object","webpack://Parchment/./src/error.ts","webpack://Parchment/./src/registry.ts","webpack://Parchment/./src/blot/abstract/shadow.ts","webpack://Parchment/./src/blot/abstract/parent.ts","webpack://Parchment/./src/collection/linked-list.ts","webpack://Parchment/./src/blot/abstract/container.ts","webpack://Parchment/./src/blot/abstract/leaf.ts","webpack://Parchment/./src/attributor/attributor.ts","webpack://Parchment/./src/attributor/class.ts","webpack://Parchment/./src/attributor/style.ts","webpack://Parchment/./src/attributor/store.ts","webpack://Parchment/./src/blot/inline.ts","webpack://Parchment/./src/blot/block.ts","webpack://Parchment/./src/blot/embed.ts","webpack://Parchment/./src/blot/scroll.ts","webpack://Parchment/./src/blot/text.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Parchment\"] = factory();\n\telse\n\t\troot[\"Parchment\"] = factory();\n})((() => {\n        if (typeof self !== 'undefined') {\n            return self;\n        } else if (typeof window !== 'undefined') {\n            return window;\n        } else if (typeof global !== 'undefined') {\n            return global;\n        } else {\n            return Function('return this')();\n        }\n    })(), function() {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","enum Scope {\n  TYPE = (1 << 2) - 1, // 0011 Lower two bits\n  LEVEL = ((1 << 2) - 1) << 2, // 1100 Higher two bits\n\n  ATTRIBUTE = (1 << 0) | LEVEL, // 1101\n  BLOT = (1 << 1) | LEVEL, // 1110\n  INLINE = (1 << 2) | TYPE, // 0111\n  BLOCK = (1 << 3) | TYPE, // 1011\n\n  BLOCK_BLOT = BLOCK & BLOT, // 1010\n  INLINE_BLOT = INLINE & BLOT, // 0110\n  BLOCK_ATTRIBUTE = BLOCK & ATTRIBUTE, // 1001\n  INLINE_ATTRIBUTE = INLINE & ATTRIBUTE, // 0101\n\n  ANY = TYPE | LEVEL,\n}\n\nexport default Scope;\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export default class ParchmentError extends Error {\n  public message: string;\n  public name: string;\n  public stack!: string;\n\n  constructor(message: string) {\n    message = '[Parchment] ' + message;\n    super(message);\n    this.message = message;\n    this.name = this.constructor.name;\n  }\n}\n","import Attributor from './attributor/attributor';\nimport { Blot, BlotConstructor, Root } from './blot/abstract/blot';\nimport ParchmentError from './error';\nimport Scope from './scope';\n\nexport interface RegistryInterface {\n  create(sroll: Root, input: Node | string | Scope, value?: any): Blot;\n  query(\n    query: string | Node | Scope,\n    scope: Scope,\n  ): Attributor | BlotConstructor | null;\n  register(...definitions: any[]): any;\n}\n\nexport default class Registry implements RegistryInterface {\n  public static blots = new WeakMap<Node, Blot>();\n\n  public static find(node: Node | null, bubble = false): Blot | null {\n    if (node == null) {\n      return null;\n    }\n    if (this.blots.has(node)) {\n      return this.blots.get(node) || null;\n    }\n    if (bubble) {\n      return this.find(node.parentNode, bubble);\n    }\n    return null;\n  }\n\n  private attributes: { [key: string]: Attributor } = {};\n  private classes: { [key: string]: BlotConstructor } = {};\n  private tags: { [key: string]: BlotConstructor } = {};\n  private types: { [key: string]: Attributor | BlotConstructor } = {};\n\n  public create(scroll: Root, input: Node | string | Scope, value?: any): Blot {\n    const match = this.query(input);\n    if (match == null) {\n      throw new ParchmentError(`Unable to create ${input} blot`);\n    }\n    const blotClass = match as BlotConstructor;\n    const node =\n      // @ts-expect-error\n      input instanceof Node || input.nodeType === Node.TEXT_NODE\n        ? input\n        : blotClass.create(value);\n\n    const blot = new blotClass(scroll, node as Node, value);\n    Registry.blots.set(blot.domNode, blot);\n    return blot;\n  }\n\n  public find(node: Node | null, bubble = false): Blot | null {\n    return Registry.find(node, bubble);\n  }\n\n  public query(\n    query: string | Node | Scope,\n    scope: Scope = Scope.ANY,\n  ): Attributor | BlotConstructor | null {\n    let match;\n    if (typeof query === 'string') {\n      match = this.types[query] || this.attributes[query];\n      // @ts-expect-error\n    } else if (query instanceof Text || query.nodeType === Node.TEXT_NODE) {\n      match = this.types.text;\n    } else if (typeof query === 'number') {\n      if (query & Scope.LEVEL & Scope.BLOCK) {\n        match = this.types.block;\n      } else if (query & Scope.LEVEL & Scope.INLINE) {\n        match = this.types.inline;\n      }\n    } else if (query instanceof HTMLElement) {\n      const names = (query.getAttribute('class') || '').split(/\\s+/);\n      names.some((name) => {\n        match = this.classes[name];\n        if (match) {\n          return true;\n        }\n        return false;\n      });\n      match = match || this.tags[query.tagName];\n    }\n    if (match == null) {\n      return null;\n    }\n    // @ts-expect-error\n    if (scope & Scope.LEVEL & match.scope && scope & Scope.TYPE & match.scope) {\n      return match;\n    }\n    return null;\n  }\n\n  public register(...definitions: any[]): any {\n    if (definitions.length > 1) {\n      return definitions.map((d) => {\n        return this.register(d);\n      });\n    }\n    const definition = definitions[0];\n    if (\n      typeof definition.blotName !== 'string' &&\n      typeof definition.attrName !== 'string'\n    ) {\n      throw new ParchmentError('Invalid definition');\n    } else if (definition.blotName === 'abstract') {\n      throw new ParchmentError('Cannot register abstract class');\n    }\n    this.types[definition.blotName || definition.attrName] = definition;\n    if (typeof definition.keyName === 'string') {\n      this.attributes[definition.keyName] = definition;\n    } else {\n      if (definition.className != null) {\n        this.classes[definition.className] = definition;\n      }\n      if (definition.tagName != null) {\n        if (Array.isArray(definition.tagName)) {\n          definition.tagName = definition.tagName.map((tagName: string) => {\n            return tagName.toUpperCase();\n          });\n        } else {\n          definition.tagName = definition.tagName.toUpperCase();\n        }\n        const tagNames = Array.isArray(definition.tagName)\n          ? definition.tagName\n          : [definition.tagName];\n        tagNames.forEach((tag: string) => {\n          if (this.tags[tag] == null || definition.className == null) {\n            this.tags[tag] = definition;\n          }\n        });\n      }\n    }\n    return definition;\n  }\n}\n","import ParchmentError from '../../error';\nimport Registry from '../../registry';\nimport Scope from '../../scope';\nimport { Blot, BlotConstructor, Formattable, Parent, Root } from './blot';\n\nclass ShadowBlot implements Blot {\n  public static blotName = 'abstract';\n  public static className: string;\n  public static requiredContainer: BlotConstructor;\n  public static scope: Scope;\n  public static tagName: string;\n\n  public static create(value: any): Node {\n    if (this.tagName == null) {\n      throw new ParchmentError('Blot definition missing tagName');\n    }\n    let node;\n    if (Array.isArray(this.tagName)) {\n      if (typeof value === 'string') {\n        value = value.toUpperCase();\n        if (parseInt(value, 10).toString() === value) {\n          value = parseInt(value, 10);\n        }\n      }\n      if (typeof value === 'number') {\n        node = document.createElement(this.tagName[value - 1]);\n      } else if (this.tagName.indexOf(value) > -1) {\n        node = document.createElement(value);\n      } else {\n        node = document.createElement(this.tagName[0]);\n      }\n    } else {\n      node = document.createElement(this.tagName);\n    }\n    if (this.className) {\n      node.classList.add(this.className);\n    }\n    return node;\n  }\n\n  public prev: Blot | null;\n  public next: Blot | null;\n  // @ts-expect-error\n  public parent: Parent;\n\n  // Hack for accessing inherited static methods\n  get statics(): any {\n    return this.constructor;\n  }\n  constructor(public scroll: Root, public domNode: Node) {\n    Registry.blots.set(domNode, this);\n    this.prev = null;\n    this.next = null;\n  }\n\n  public attach(): void {\n    // Nothing to do\n  }\n\n  public clone(): Blot {\n    const domNode = this.domNode.cloneNode(false);\n    return this.scroll.create(domNode);\n  }\n\n  public detach(): void {\n    if (this.parent != null) {\n      this.parent.removeChild(this);\n    }\n    Registry.blots.delete(this.domNode);\n  }\n\n  public deleteAt(index: number, length: number): void {\n    const blot = this.isolate(index, length);\n    blot.remove();\n  }\n\n  public formatAt(\n    index: number,\n    length: number,\n    name: string,\n    value: any,\n  ): void {\n    const blot = this.isolate(index, length);\n    if (this.scroll.query(name, Scope.BLOT) != null && value) {\n      blot.wrap(name, value);\n    } else if (this.scroll.query(name, Scope.ATTRIBUTE) != null) {\n      const parent = this.scroll.create(this.statics.scope) as Parent &\n        Formattable;\n      blot.wrap(parent);\n      parent.format(name, value);\n    }\n  }\n\n  public insertAt(index: number, value: string, def?: any): void {\n    const blot =\n      def == null\n        ? this.scroll.create('text', value)\n        : this.scroll.create(value, def);\n    const ref = this.split(index);\n    this.parent.insertBefore(blot, ref || undefined);\n  }\n\n  public isolate(index: number, length: number): Blot {\n    const target = this.split(index);\n    if (target == null) {\n      throw new Error('Attempt to isolate at end');\n    }\n    target.split(length);\n    return target;\n  }\n\n  public length(): number {\n    return 1;\n  }\n\n  public offset(root: Blot = this.parent): number {\n    if (this.parent == null || this === root) {\n      return 0;\n    }\n    return this.parent.children.offset(this) + this.parent.offset(root);\n  }\n\n  public optimize(_context: { [key: string]: any }): void {\n    if (\n      this.statics.requiredContainer &&\n      !(this.parent instanceof this.statics.requiredContainer)\n    ) {\n      this.wrap(this.statics.requiredContainer.blotName);\n    }\n  }\n\n  public remove(): void {\n    if (this.domNode.parentNode != null) {\n      this.domNode.parentNode.removeChild(this.domNode);\n    }\n    this.detach();\n  }\n\n  public replaceWith(name: string | Blot, value?: any): Blot {\n    const replacement =\n      typeof name === 'string' ? this.scroll.create(name, value) : name;\n    if (this.parent != null) {\n      this.parent.insertBefore(replacement, this.next || undefined);\n      this.remove();\n    }\n    return replacement;\n  }\n\n  public split(index: number, _force?: boolean): Blot | null {\n    return index === 0 ? this : this.next;\n  }\n\n  public update(\n    _mutations: MutationRecord[],\n    _context: { [key: string]: any },\n  ): void {\n    // Nothing to do by default\n  }\n\n  public wrap(name: string | Parent, value?: any): Parent {\n    const wrapper =\n      typeof name === 'string'\n        ? (this.scroll.create(name, value) as Parent)\n        : name;\n    if (this.parent != null) {\n      this.parent.insertBefore(wrapper, this.next || undefined);\n    }\n    if (typeof wrapper.appendChild !== 'function') {\n      throw new ParchmentError(`Cannot wrap ${name}`);\n    }\n    wrapper.appendChild(this);\n    return wrapper;\n  }\n}\n\nexport default ShadowBlot;\n","import LinkedList from '../../collection/linked-list';\nimport ParchmentError from '../../error';\nimport Scope from '../../scope';\nimport { Blot, BlotConstructor, Parent, Root } from './blot';\nimport ShadowBlot from './shadow';\n\nfunction makeAttachedBlot(node: Node, scroll: Root): Blot {\n  let blot = scroll.find(node);\n  if (blot == null) {\n    try {\n      blot = scroll.create(node);\n    } catch (e) {\n      blot = scroll.create(Scope.INLINE) as Blot;\n      Array.from(node.childNodes).forEach((child: Node) => {\n        // @ts-expect-error\n        blot.domNode.appendChild(child);\n      });\n      if (node.parentNode) {\n        node.parentNode.replaceChild(blot.domNode, node);\n      }\n      blot.attach();\n    }\n  }\n  return blot as Blot;\n}\n\nclass ParentBlot extends ShadowBlot implements Parent {\n  public static allowedChildren: BlotConstructor[] | null;\n  public static defaultChild: BlotConstructor | null;\n  public static uiClass = '';\n\n  public children!: LinkedList<Blot>;\n  public domNode!: HTMLElement;\n  public uiNode: HTMLElement | null = null;\n\n  constructor(scroll: Root, domNode: Node) {\n    super(scroll, domNode);\n    this.build();\n  }\n\n  public appendChild(other: Blot): void {\n    this.insertBefore(other);\n  }\n\n  public attach(): void {\n    super.attach();\n    this.children.forEach((child) => {\n      child.attach();\n    });\n  }\n\n  public attachUI(node: HTMLElement): void {\n    if (this.uiNode != null) {\n      this.uiNode.remove();\n    }\n    this.uiNode = node;\n    if (ParentBlot.uiClass) {\n      this.uiNode.classList.add(ParentBlot.uiClass);\n    }\n    this.uiNode.setAttribute('contenteditable', 'false');\n    this.domNode.insertBefore(this.uiNode, this.domNode.firstChild);\n  }\n\n  public build(): void {\n    this.children = new LinkedList<Blot>();\n    // Need to be reversed for if DOM nodes already in order\n    Array.from(this.domNode.childNodes)\n      .filter((node: Node) => node !== this.uiNode)\n      .reverse()\n      .forEach((node: Node) => {\n        try {\n          const child = makeAttachedBlot(node, this.scroll);\n          this.insertBefore(child, this.children.head || undefined);\n        } catch (err) {\n          if (err instanceof ParchmentError) {\n            return;\n          } else {\n            throw err;\n          }\n        }\n      });\n  }\n\n  public deleteAt(index: number, length: number): void {\n    if (index === 0 && length === this.length()) {\n      return this.remove();\n    }\n    this.children.forEachAt(index, length, (child, offset, childLength) => {\n      child.deleteAt(offset, childLength);\n    });\n  }\n\n  public descendant(\n    criteria: new () => Blot,\n    index: number,\n  ): [Blot | null, number];\n  public descendant(\n    criteria: (blot: Blot) => boolean,\n    index: number,\n  ): [Blot | null, number];\n  public descendant(criteria: any, index = 0): [Blot | null, number] {\n    const [child, offset] = this.children.find(index);\n    if (\n      (criteria.blotName == null && criteria(child)) ||\n      (criteria.blotName != null && child instanceof criteria)\n    ) {\n      return [child as any, offset];\n    } else if (child instanceof ParentBlot) {\n      return child.descendant(criteria, offset);\n    } else {\n      return [null, -1];\n    }\n  }\n\n  public descendants(\n    criteria: new () => Blot,\n    index: number,\n    length: number,\n  ): Blot[];\n  public descendants(\n    criteria: (blot: Blot) => boolean,\n    index: number,\n    length: number,\n  ): Blot[];\n  public descendants(\n    criteria: any,\n    index = 0,\n    length: number = Number.MAX_VALUE,\n  ): Blot[] {\n    let descendants: Blot[] = [];\n    let lengthLeft = length;\n    this.children.forEachAt(\n      index,\n      length,\n      (child: Blot, childIndex: number, childLength: number) => {\n        if (\n          (criteria.blotName == null && criteria(child)) ||\n          (criteria.blotName != null && child instanceof criteria)\n        ) {\n          descendants.push(child);\n        }\n        if (child instanceof ParentBlot) {\n          descendants = descendants.concat(\n            child.descendants(criteria, childIndex, lengthLeft),\n          );\n        }\n        lengthLeft -= childLength;\n      },\n    );\n    return descendants;\n  }\n\n  public detach(): void {\n    this.children.forEach((child) => {\n      child.detach();\n    });\n    super.detach();\n  }\n\n  public enforceAllowedChildren(): void {\n    let done = false;\n    this.children.forEach((child: Blot) => {\n      if (done) {\n        return;\n      }\n      const allowed = this.statics.allowedChildren.some(\n        (def: BlotConstructor) => child instanceof def,\n      );\n      if (allowed) {\n        return;\n      }\n      if (child.statics.scope === Scope.BLOCK_BLOT) {\n        if (child.next != null) {\n          this.splitAfter(child);\n        }\n        if (child.prev != null) {\n          this.splitAfter(child.prev);\n        }\n        child.parent.unwrap();\n        done = true;\n      } else if (child instanceof ParentBlot) {\n        child.unwrap();\n      } else {\n        child.remove();\n      }\n    });\n  }\n\n  public formatAt(\n    index: number,\n    length: number,\n    name: string,\n    value: any,\n  ): void {\n    this.children.forEachAt(index, length, (child, offset, childLength) => {\n      child.formatAt(offset, childLength, name, value);\n    });\n  }\n\n  public insertAt(index: number, value: string, def?: any): void {\n    const [child, offset] = this.children.find(index);\n    if (child) {\n      child.insertAt(offset, value, def);\n    } else {\n      const blot =\n        def == null\n          ? this.scroll.create('text', value)\n          : this.scroll.create(value, def);\n      this.appendChild(blot);\n    }\n  }\n\n  public insertBefore(childBlot: Blot, refBlot?: Blot | null): void {\n    if (childBlot.parent != null) {\n      childBlot.parent.children.remove(childBlot);\n    }\n    let refDomNode: Node | null = null;\n    this.children.insertBefore(childBlot, refBlot || null);\n    childBlot.parent = this;\n    if (refBlot != null) {\n      refDomNode = refBlot.domNode;\n    }\n    if (\n      this.domNode.parentNode !== childBlot.domNode ||\n      this.domNode.nextSibling !== refDomNode\n    ) {\n      this.domNode.insertBefore(childBlot.domNode, refDomNode);\n    }\n    childBlot.attach();\n  }\n\n  public length(): number {\n    return this.children.reduce((memo, child) => {\n      return memo + child.length();\n    }, 0);\n  }\n\n  public moveChildren(targetParent: Parent, refNode?: Blot): void {\n    this.children.forEach((child) => {\n      targetParent.insertBefore(child, refNode);\n    });\n  }\n\n  public optimize(context: { [key: string]: any }): void {\n    super.optimize(context);\n    this.enforceAllowedChildren();\n    if (this.uiNode != null && this.uiNode !== this.domNode.firstChild) {\n      this.domNode.insertBefore(this.uiNode, this.domNode.firstChild);\n    }\n    if (this.children.length === 0) {\n      if (this.statics.defaultChild != null) {\n        const child = this.scroll.create(this.statics.defaultChild.blotName);\n        this.appendChild(child);\n        // TODO double check if necessary\n        // child.optimize(context);\n      } else {\n        this.remove();\n      }\n    }\n  }\n\n  public path(index: number, inclusive = false): [Blot, number][] {\n    const [child, offset] = this.children.find(index, inclusive);\n    const position: [Blot, number][] = [[this, index]];\n    if (child instanceof ParentBlot) {\n      return position.concat(child.path(offset, inclusive));\n    } else if (child != null) {\n      position.push([child, offset]);\n    }\n    return position;\n  }\n\n  public removeChild(child: Blot): void {\n    this.children.remove(child);\n  }\n\n  public replaceWith(name: string | Blot, value?: any): Blot {\n    const replacement =\n      typeof name === 'string' ? this.scroll.create(name, value) : name;\n    if (replacement instanceof ParentBlot) {\n      this.moveChildren(replacement);\n    }\n    return super.replaceWith(replacement);\n  }\n\n  public split(index: number, force = false): Blot | null {\n    if (!force) {\n      if (index === 0) {\n        return this;\n      }\n      if (index === this.length()) {\n        return this.next;\n      }\n    }\n    const after = this.clone() as ParentBlot;\n    if (this.parent) {\n      this.parent.insertBefore(after, this.next || undefined);\n    }\n    this.children.forEachAt(index, this.length(), (child, offset, _length) => {\n      const split = child.split(offset, force);\n      if (split != null) {\n        after.appendChild(split);\n      }\n    });\n    return after;\n  }\n\n  public splitAfter(child: Blot): Parent {\n    const after = this.clone() as ParentBlot;\n    while (child.next != null) {\n      after.appendChild(child.next);\n    }\n    if (this.parent) {\n      this.parent.insertBefore(after, this.next || undefined);\n    }\n    return after;\n  }\n\n  public unwrap(): void {\n    if (this.parent) {\n      this.moveChildren(this.parent, this.next || undefined);\n    }\n    this.remove();\n  }\n\n  public update(\n    mutations: MutationRecord[],\n    _context: { [key: string]: any },\n  ): void {\n    const addedNodes: Node[] = [];\n    const removedNodes: Node[] = [];\n    mutations.forEach((mutation) => {\n      if (mutation.target === this.domNode && mutation.type === 'childList') {\n        addedNodes.push(...mutation.addedNodes);\n        removedNodes.push(...mutation.removedNodes);\n      }\n    });\n    removedNodes.forEach((node: Node) => {\n      // Check node has actually been removed\n      // One exception is Chrome does not immediately remove IFRAMEs\n      // from DOM but MutationRecord is correct in its reported removal\n      if (\n        node.parentNode != null &&\n        // @ts-expect-error\n        node.tagName !== 'IFRAME' &&\n        document.body.compareDocumentPosition(node) &\n          Node.DOCUMENT_POSITION_CONTAINED_BY\n      ) {\n        return;\n      }\n      const blot = this.scroll.find(node);\n      if (blot == null) {\n        return;\n      }\n      if (\n        blot.domNode.parentNode == null ||\n        blot.domNode.parentNode === this.domNode\n      ) {\n        blot.detach();\n      }\n    });\n    addedNodes\n      .filter((node) => {\n        return node.parentNode === this.domNode || node === this.uiNode;\n      })\n      .sort((a, b) => {\n        if (a === b) {\n          return 0;\n        }\n        if (a.compareDocumentPosition(b) & Node.DOCUMENT_POSITION_FOLLOWING) {\n          return 1;\n        }\n        return -1;\n      })\n      .forEach((node) => {\n        let refBlot: Blot | null = null;\n        if (node.nextSibling != null) {\n          refBlot = this.scroll.find(node.nextSibling);\n        }\n        const blot = makeAttachedBlot(node, this.scroll);\n        if (blot.next !== refBlot || blot.next == null) {\n          if (blot.parent != null) {\n            blot.parent.removeChild(this);\n          }\n          this.insertBefore(blot, refBlot || undefined);\n        }\n      });\n    this.enforceAllowedChildren();\n  }\n}\n\nexport default ParentBlot;\n","import LinkedNode from './linked-node';\n\nclass LinkedList<T extends LinkedNode> {\n  public head: T | null;\n  public tail: T | null;\n  public length: number;\n\n  constructor() {\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n\n  public append(...nodes: T[]): void {\n    this.insertBefore(nodes[0], null);\n    if (nodes.length > 1) {\n      const rest = nodes.slice(1);\n      this.append(...rest);\n    }\n  }\n\n  public at(index: number): T | null {\n    const next = this.iterator();\n    let cur = next();\n    while (cur && index > 0) {\n      index -= 1;\n      cur = next();\n    }\n    return cur;\n  }\n\n  public contains(node: T): boolean {\n    const next = this.iterator();\n    let cur = next();\n    while (cur) {\n      if (cur === node) {\n        return true;\n      }\n      cur = next();\n    }\n    return false;\n  }\n\n  public indexOf(node: T): number {\n    const next = this.iterator();\n    let cur = next();\n    let index = 0;\n    while (cur) {\n      if (cur === node) {\n        return index;\n      }\n      index += 1;\n      cur = next();\n    }\n    return -1;\n  }\n\n  public insertBefore(node: T | null, refNode: T | null): void {\n    if (node == null) {\n      return;\n    }\n    this.remove(node);\n    node.next = refNode;\n    if (refNode != null) {\n      node.prev = refNode.prev;\n      if (refNode.prev != null) {\n        refNode.prev.next = node;\n      }\n      refNode.prev = node;\n      if (refNode === this.head) {\n        this.head = node;\n      }\n    } else if (this.tail != null) {\n      this.tail.next = node;\n      node.prev = this.tail;\n      this.tail = node;\n    } else {\n      node.prev = null;\n      this.head = this.tail = node;\n    }\n    this.length += 1;\n  }\n\n  public offset(target: T): number {\n    let index = 0;\n    let cur = this.head;\n    while (cur != null) {\n      if (cur === target) {\n        return index;\n      }\n      index += cur.length();\n      cur = cur.next as T;\n    }\n    return -1;\n  }\n\n  public remove(node: T): void {\n    if (!this.contains(node)) {\n      return;\n    }\n    if (node.prev != null) {\n      node.prev.next = node.next;\n    }\n    if (node.next != null) {\n      node.next.prev = node.prev;\n    }\n    if (node === this.head) {\n      this.head = node.next as T;\n    }\n    if (node === this.tail) {\n      this.tail = node.prev as T;\n    }\n    this.length -= 1;\n  }\n\n  public iterator(curNode: T | null = this.head): () => T | null {\n    // TODO use yield when we can\n    return (): T | null => {\n      const ret = curNode;\n      if (curNode != null) {\n        curNode = curNode.next as T;\n      }\n      return ret;\n    };\n  }\n\n  public find(index: number, inclusive = false): [T | null, number] {\n    const next = this.iterator();\n    let cur = next();\n    while (cur) {\n      const length = cur.length();\n      if (\n        index < length ||\n        (inclusive &&\n          index === length &&\n          (cur.next == null || cur.next.length() !== 0))\n      ) {\n        return [cur, index];\n      }\n      index -= length;\n      cur = next();\n    }\n    return [null, 0];\n  }\n\n  public forEach(callback: (cur: T) => void): void {\n    const next = this.iterator();\n    let cur = next();\n    while (cur) {\n      callback(cur);\n      cur = next();\n    }\n  }\n\n  public forEachAt(\n    index: number,\n    length: number,\n    callback: (cur: T, offset: number, length: number) => void,\n  ): void {\n    if (length <= 0) {\n      return;\n    }\n    const [startNode, offset] = this.find(index);\n    let curIndex = index - offset;\n    const next = this.iterator(startNode);\n    let cur = next();\n    while (cur && curIndex < index + length) {\n      const curLength = cur.length();\n      if (index > curIndex) {\n        callback(\n          cur,\n          index - curIndex,\n          Math.min(length, curIndex + curLength - index),\n        );\n      } else {\n        callback(cur, 0, Math.min(curLength, index + length - curIndex));\n      }\n      curIndex += curLength;\n      cur = next();\n    }\n  }\n\n  public map(callback: (cur: T) => any): any[] {\n    return this.reduce((memo: T[], cur: T) => {\n      memo.push(callback(cur));\n      return memo;\n    }, []);\n  }\n\n  public reduce<M>(callback: (memo: M, cur: T) => M, memo: M): M {\n    const next = this.iterator();\n    let cur = next();\n    while (cur) {\n      memo = callback(memo, cur);\n      cur = next();\n    }\n    return memo;\n  }\n}\n\nexport default LinkedList;\n","import Scope from '../../scope';\nimport BlockBlot from '../block';\nimport ParentBlot from './parent';\n\nclass ContainerBlot extends ParentBlot {\n  public static blotName = 'container';\n  public static scope = Scope.BLOCK_BLOT;\n  public static tagName: string;\n\n  public prev!: BlockBlot | ContainerBlot | null;\n  public next!: BlockBlot | ContainerBlot | null;\n\n  public checkMerge(): boolean {\n    return (\n      this.next !== null && this.next.statics.blotName === this.statics.blotName\n    );\n  }\n\n  public deleteAt(index: number, length: number): void {\n    super.deleteAt(index, length);\n    this.enforceAllowedChildren();\n  }\n\n  public formatAt(\n    index: number,\n    length: number,\n    name: string,\n    value: any,\n  ): void {\n    super.formatAt(index, length, name, value);\n    this.enforceAllowedChildren();\n  }\n\n  public insertAt(index: number, value: string, def?: any): void {\n    super.insertAt(index, value, def);\n    this.enforceAllowedChildren();\n  }\n\n  public optimize(context: { [key: string]: any }): void {\n    super.optimize(context);\n    if (this.children.length > 0 && this.next != null && this.checkMerge()) {\n      this.next.moveChildren(this);\n      this.next.remove();\n    }\n  }\n}\n\nexport default ContainerBlot;\n","import Scope from '../../scope';\nimport { Leaf } from './blot';\nimport ShadowBlot from './shadow';\n\nclass LeafBlot extends ShadowBlot implements Leaf {\n  public static scope = Scope.INLINE_BLOT;\n\n  public static value(_domNode: Node): any {\n    return true;\n  }\n\n  public index(node: Node, offset: number): number {\n    if (\n      this.domNode === node ||\n      this.domNode.compareDocumentPosition(node) &\n        Node.DOCUMENT_POSITION_CONTAINED_BY\n    ) {\n      return Math.min(offset, 1);\n    }\n    return -1;\n  }\n\n  public position(index: number, _inclusive?: boolean): [Node, number] {\n    const childNodes: Node[] = Array.from(this.parent.domNode.childNodes);\n    let offset = childNodes.indexOf(this.domNode);\n    if (index > 0) {\n      offset += 1;\n    }\n    return [this.parent.domNode, offset];\n  }\n\n  public value(): any {\n    return {\n      [this.statics.blotName]: this.statics.value(this.domNode) || true,\n    };\n  }\n}\n\nexport default LeafBlot;\n","import Scope from '../scope';\n\nexport interface AttributorOptions {\n  scope?: Scope;\n  whitelist?: string[];\n}\n\nexport default class Attributor {\n  public static keys(node: HTMLElement): string[] {\n    return Array.from(node.attributes).map((item: Attr) => item.name);\n  }\n\n  public attrName: string;\n  public keyName: string;\n  public scope: Scope;\n  public whitelist: string[] | undefined;\n\n  constructor(\n    attrName: string,\n    keyName: string,\n    options: AttributorOptions = {},\n  ) {\n    this.attrName = attrName;\n    this.keyName = keyName;\n    const attributeBit = Scope.TYPE & Scope.ATTRIBUTE;\n    this.scope =\n      options.scope != null\n        ? // Ignore type bits, force attribute bit\n          (options.scope & Scope.LEVEL) | attributeBit\n        : Scope.ATTRIBUTE;\n    if (options.whitelist != null) {\n      this.whitelist = options.whitelist;\n    }\n  }\n\n  public add(node: HTMLElement, value: string): boolean {\n    if (!this.canAdd(node, value)) {\n      return false;\n    }\n    node.setAttribute(this.keyName, value);\n    return true;\n  }\n\n  public canAdd(_node: HTMLElement, value: any): boolean {\n    if (this.whitelist == null) {\n      return true;\n    }\n    if (typeof value === 'string') {\n      return this.whitelist.indexOf(value.replace(/[\"']/g, '')) > -1;\n    } else {\n      return this.whitelist.indexOf(value) > -1;\n    }\n  }\n\n  public remove(node: HTMLElement): void {\n    node.removeAttribute(this.keyName);\n  }\n\n  public value(node: HTMLElement): string {\n    const value = node.getAttribute(this.keyName);\n    if (this.canAdd(node, value) && value) {\n      return value;\n    }\n    return '';\n  }\n}\n","import Attributor from './attributor';\n\nfunction match(node: HTMLElement, prefix: string): string[] {\n  const className = node.getAttribute('class') || '';\n  return className\n    .split(/\\s+/)\n    .filter((name) => name.indexOf(`${prefix}-`) === 0);\n}\n\nclass ClassAttributor extends Attributor {\n  public static keys(node: HTMLElement): string[] {\n    return (node.getAttribute('class') || '')\n      .split(/\\s+/)\n      .map((name) => name.split('-').slice(0, -1).join('-'));\n  }\n\n  public add(node: HTMLElement, value: string): boolean {\n    if (!this.canAdd(node, value)) {\n      return false;\n    }\n    this.remove(node);\n    node.classList.add(`${this.keyName}-${value}`);\n    return true;\n  }\n\n  public remove(node: HTMLElement): void {\n    const matches = match(node, this.keyName);\n    matches.forEach((name) => {\n      node.classList.remove(name);\n    });\n    if (node.classList.length === 0) {\n      node.removeAttribute('class');\n    }\n  }\n\n  public value(node: HTMLElement): string {\n    const result = match(node, this.keyName)[0] || '';\n    const value = result.slice(this.keyName.length + 1); // +1 for hyphen\n    return this.canAdd(node, value) ? value : '';\n  }\n}\n\nexport default ClassAttributor;\n","import Attributor from './attributor';\n\nfunction camelize(name: string): string {\n  const parts = name.split('-');\n  const rest = parts\n    .slice(1)\n    .map((part: string) => part[0].toUpperCase() + part.slice(1))\n    .join('');\n  return parts[0] + rest;\n}\n\nclass StyleAttributor extends Attributor {\n  public static keys(node: Element): string[] {\n    return (node.getAttribute('style') || '').split(';').map((value) => {\n      const arr = value.split(':');\n      return arr[0].trim();\n    });\n  }\n\n  public add(node: HTMLElement, value: string): boolean {\n    if (!this.canAdd(node, value)) {\n      return false;\n    }\n    // @ts-expect-error\n    node.style[camelize(this.keyName)] = value;\n    return true;\n  }\n\n  public remove(node: HTMLElement): void {\n    // @ts-expect-error\n    node.style[camelize(this.keyName)] = '';\n    if (!node.getAttribute('style')) {\n      node.removeAttribute('style');\n    }\n  }\n\n  public value(node: HTMLElement): string {\n    // @ts-expect-error\n    const value = node.style[camelize(this.keyName)];\n    return this.canAdd(node, value) ? value : '';\n  }\n}\n\nexport default StyleAttributor;\n","import { Formattable } from '../blot/abstract/blot';\nimport Registry from '../registry';\nimport Scope from '../scope';\nimport Attributor from './attributor';\nimport ClassAttributor from './class';\nimport StyleAttributor from './style';\n\nclass AttributorStore {\n  private attributes: { [key: string]: Attributor } = {};\n  private domNode: HTMLElement;\n\n  constructor(domNode: HTMLElement) {\n    this.domNode = domNode;\n    this.build();\n  }\n\n  public attribute(attribute: Attributor, value: any): void {\n    // verb\n    if (value) {\n      if (attribute.add(this.domNode, value)) {\n        if (attribute.value(this.domNode) != null) {\n          this.attributes[attribute.attrName] = attribute;\n        } else {\n          delete this.attributes[attribute.attrName];\n        }\n      }\n    } else {\n      attribute.remove(this.domNode);\n      delete this.attributes[attribute.attrName];\n    }\n  }\n\n  public build(): void {\n    this.attributes = {};\n    const blot = Registry.find(this.domNode);\n    if (blot == null) {\n      return;\n    }\n    const attributes = Attributor.keys(this.domNode);\n    const classes = ClassAttributor.keys(this.domNode);\n    const styles = StyleAttributor.keys(this.domNode);\n    attributes\n      .concat(classes)\n      .concat(styles)\n      .forEach((name) => {\n        const attr = blot.scroll.query(name, Scope.ATTRIBUTE);\n        if (attr instanceof Attributor) {\n          this.attributes[attr.attrName] = attr;\n        }\n      });\n  }\n\n  public copy(target: Formattable): void {\n    Object.keys(this.attributes).forEach((key) => {\n      const value = this.attributes[key].value(this.domNode);\n      target.format(key, value);\n    });\n  }\n\n  public move(target: Formattable): void {\n    this.copy(target);\n    Object.keys(this.attributes).forEach((key) => {\n      this.attributes[key].remove(this.domNode);\n    });\n    this.attributes = {};\n  }\n\n  public values(): { [key: string]: any } {\n    return Object.keys(this.attributes).reduce(\n      (attributes: { [key: string]: any }, name: string) => {\n        attributes[name] = this.attributes[name].value(this.domNode);\n        return attributes;\n      },\n      {},\n    );\n  }\n}\n\nexport default AttributorStore;\n","import Attributor from '../attributor/attributor';\nimport AttributorStore from '../attributor/store';\nimport Scope from '../scope';\nimport {\n  Blot,\n  BlotConstructor,\n  Formattable,\n  Parent,\n  Root,\n} from './abstract/blot';\nimport LeafBlot from './abstract/leaf';\nimport ParentBlot from './abstract/parent';\n\n// Shallow object comparison\nfunction isEqual(obj1: object, obj2: object): boolean {\n  if (Object.keys(obj1).length !== Object.keys(obj2).length) {\n    return false;\n  }\n  for (const prop in obj1) {\n    // @ts-expect-error\n    if (obj1[prop] !== obj2[prop]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nclass InlineBlot extends ParentBlot implements Formattable {\n  public static allowedChildren: BlotConstructor[] = [InlineBlot, LeafBlot];\n  public static blotName = 'inline';\n  public static scope = Scope.INLINE_BLOT;\n  public static tagName = 'SPAN';\n\n  public static formats(domNode: HTMLElement, scroll: Root): any {\n    const match = scroll.query(InlineBlot.blotName);\n    if (\n      match != null &&\n      domNode.tagName === (match as BlotConstructor).tagName\n    ) {\n      return undefined;\n    } else if (typeof this.tagName === 'string') {\n      return true;\n    } else if (Array.isArray(this.tagName)) {\n      return domNode.tagName.toLowerCase();\n    }\n    return undefined;\n  }\n\n  protected attributes: AttributorStore;\n\n  constructor(scroll: Root, domNode: Node) {\n    super(scroll, domNode);\n    this.attributes = new AttributorStore(this.domNode);\n  }\n\n  public format(name: string, value: any): void {\n    if (name === this.statics.blotName && !value) {\n      this.children.forEach((child) => {\n        if (!(child instanceof InlineBlot)) {\n          child = child.wrap(InlineBlot.blotName, true);\n        }\n        this.attributes.copy(child as InlineBlot);\n      });\n      this.unwrap();\n    } else {\n      const format = this.scroll.query(name, Scope.INLINE);\n      if (format == null) {\n        return;\n      }\n      if (format instanceof Attributor) {\n        this.attributes.attribute(format, value);\n      } else if (\n        value &&\n        (name !== this.statics.blotName || this.formats()[name] !== value)\n      ) {\n        this.replaceWith(name, value);\n      }\n    }\n  }\n\n  public formats(): { [index: string]: any } {\n    const formats = this.attributes.values();\n    const format = this.statics.formats(this.domNode, this.scroll);\n    if (format != null) {\n      formats[this.statics.blotName] = format;\n    }\n    return formats;\n  }\n\n  public formatAt(\n    index: number,\n    length: number,\n    name: string,\n    value: any,\n  ): void {\n    if (\n      this.formats()[name] != null ||\n      this.scroll.query(name, Scope.ATTRIBUTE)\n    ) {\n      const blot = this.isolate(index, length) as InlineBlot;\n      blot.format(name, value);\n    } else {\n      super.formatAt(index, length, name, value);\n    }\n  }\n\n  public optimize(context: { [key: string]: any }): void {\n    super.optimize(context);\n    const formats = this.formats();\n    if (Object.keys(formats).length === 0) {\n      return this.unwrap(); // unformatted span\n    }\n    const next = this.next;\n    if (\n      next instanceof InlineBlot &&\n      next.prev === this &&\n      isEqual(formats, next.formats())\n    ) {\n      next.moveChildren(this);\n      next.remove();\n    }\n  }\n\n  public replaceWith(name: string | Blot, value?: any): Blot {\n    const replacement = super.replaceWith(name, value) as InlineBlot;\n    this.attributes.copy(replacement);\n    return replacement;\n  }\n\n  public update(\n    mutations: MutationRecord[],\n    context: { [key: string]: any },\n  ): void {\n    super.update(mutations, context);\n    const attributeChanged = mutations.some(\n      (mutation) =>\n        mutation.target === this.domNode && mutation.type === 'attributes',\n    );\n    if (attributeChanged) {\n      this.attributes.build();\n    }\n  }\n\n  public wrap(name: string | Parent, value?: any): Parent {\n    const wrapper = super.wrap(name, value);\n    if (wrapper instanceof InlineBlot) {\n      this.attributes.move(wrapper);\n    }\n    return wrapper;\n  }\n}\n\nexport default InlineBlot;\n","import Attributor from '../attributor/attributor';\nimport AttributorStore from '../attributor/store';\nimport Scope from '../scope';\nimport { Blot, BlotConstructor, Formattable, Root } from './abstract/blot';\nimport LeafBlot from './abstract/leaf';\nimport ParentBlot from './abstract/parent';\nimport InlineBlot from './inline';\n\nclass BlockBlot extends ParentBlot implements Formattable {\n  public static blotName = 'block';\n  public static scope = Scope.BLOCK_BLOT;\n  public static tagName = 'P';\n  public static allowedChildren: BlotConstructor[] = [\n    InlineBlot,\n    BlockBlot,\n    LeafBlot,\n  ];\n\n  public static formats(domNode: HTMLElement, scroll: Root): any {\n    const match = scroll.query(BlockBlot.blotName);\n    if (\n      match != null &&\n      domNode.tagName === (match as BlotConstructor).tagName\n    ) {\n      return undefined;\n    } else if (typeof this.tagName === 'string') {\n      return true;\n    } else if (Array.isArray(this.tagName)) {\n      return domNode.tagName.toLowerCase();\n    }\n  }\n\n  protected attributes: AttributorStore;\n\n  constructor(scroll: Root, domNode: Node) {\n    super(scroll, domNode);\n    this.attributes = new AttributorStore(this.domNode);\n  }\n\n  public format(name: string, value: any): void {\n    const format = this.scroll.query(name, Scope.BLOCK);\n    if (format == null) {\n      return;\n    } else if (format instanceof Attributor) {\n      this.attributes.attribute(format, value);\n    } else if (name === this.statics.blotName && !value) {\n      this.replaceWith(BlockBlot.blotName);\n    } else if (\n      value &&\n      (name !== this.statics.blotName || this.formats()[name] !== value)\n    ) {\n      this.replaceWith(name, value);\n    }\n  }\n\n  public formats(): { [index: string]: any } {\n    const formats = this.attributes.values();\n    const format = this.statics.formats(this.domNode, this.scroll);\n    if (format != null) {\n      formats[this.statics.blotName] = format;\n    }\n    return formats;\n  }\n\n  public formatAt(\n    index: number,\n    length: number,\n    name: string,\n    value: any,\n  ): void {\n    if (this.scroll.query(name, Scope.BLOCK) != null) {\n      this.format(name, value);\n    } else {\n      super.formatAt(index, length, name, value);\n    }\n  }\n\n  public insertAt(index: number, value: string, def?: any): void {\n    if (def == null || this.scroll.query(value, Scope.INLINE) != null) {\n      // Insert text or inline\n      super.insertAt(index, value, def);\n    } else {\n      const after = this.split(index);\n      if (after != null) {\n        const blot = this.scroll.create(value, def);\n        after.parent.insertBefore(blot, after);\n      } else {\n        throw new Error('Attempt to insertAt after block boundaries');\n      }\n    }\n  }\n\n  public replaceWith(name: string | Blot, value?: any): Blot {\n    const replacement = super.replaceWith(name, value) as BlockBlot;\n    this.attributes.copy(replacement);\n    return replacement;\n  }\n\n  public update(\n    mutations: MutationRecord[],\n    context: { [key: string]: any },\n  ): void {\n    super.update(mutations, context);\n    const attributeChanged = mutations.some(\n      (mutation) =>\n        mutation.target === this.domNode && mutation.type === 'attributes',\n    );\n    if (attributeChanged) {\n      this.attributes.build();\n    }\n  }\n}\n\nexport default BlockBlot;\n","import { Formattable, Root } from './abstract/blot';\nimport LeafBlot from './abstract/leaf';\n\nclass EmbedBlot extends LeafBlot implements Formattable {\n  public static formats(_domNode: HTMLElement, _scroll: Root): any {\n    return undefined;\n  }\n\n  public format(name: string, value: any): void {\n    // super.formatAt wraps, which is what we want in general,\n    // but this allows subclasses to overwrite for formats\n    // that just apply to particular embeds\n    super.formatAt(0, this.length(), name, value);\n  }\n\n  public formatAt(\n    index: number,\n    length: number,\n    name: string,\n    value: any,\n  ): void {\n    if (index === 0 && length === this.length()) {\n      this.format(name, value);\n    } else {\n      super.formatAt(index, length, name, value);\n    }\n  }\n\n  public formats(): { [index: string]: any } {\n    return this.statics.formats(this.domNode, this.scroll);\n  }\n}\n\nexport default EmbedBlot;\n","import Attributor from '../attributor/attributor';\nimport Registry from '../registry';\nimport Scope from '../scope';\nimport { Blot, BlotConstructor, Root } from './abstract/blot';\nimport ContainerBlot from './abstract/container';\nimport ParentBlot from './abstract/parent';\nimport BlockBlot from './block';\n\nconst OBSERVER_CONFIG = {\n  attributes: true,\n  characterData: true,\n  characterDataOldValue: true,\n  childList: true,\n  subtree: true,\n};\n\nconst MAX_OPTIMIZE_ITERATIONS = 100;\n\nclass ScrollBlot extends ParentBlot implements Root {\n  public static blotName = 'scroll';\n  public static defaultChild = BlockBlot;\n  public static allowedChildren: BlotConstructor[] = [BlockBlot, ContainerBlot];\n  public static scope = Scope.BLOCK_BLOT;\n  public static tagName = 'DIV';\n\n  public registry: Registry;\n  public observer: MutationObserver;\n\n  constructor(registry: Registry, node: HTMLDivElement) {\n    // @ts-expect-error\n    super(null, node);\n    this.registry = registry;\n    this.scroll = this;\n    this.build();\n    this.observer = new MutationObserver((mutations: MutationRecord[]) => {\n      this.update(mutations);\n    });\n    this.observer.observe(this.domNode, OBSERVER_CONFIG);\n    this.attach();\n  }\n\n  public create(input: Node | string | Scope, value?: any): Blot {\n    return this.registry.create(this, input, value);\n  }\n\n  public find(node: Node | null, bubble = false): Blot | null {\n    const blot = this.registry.find(node, bubble);\n    if (!blot) {\n      return null;\n    }\n    if (blot.scroll === this) {\n      return blot;\n    }\n    return bubble ? this.find(blot.scroll.domNode.parentNode, true) : null;\n  }\n\n  public query(\n    query: string | Node | Scope,\n    scope: Scope = Scope.ANY,\n  ): Attributor | BlotConstructor | null {\n    return this.registry.query(query, scope);\n  }\n\n  public register(...definitions: any[]): any {\n    return this.registry.register(...definitions);\n  }\n\n  public build(): void {\n    if (this.scroll == null) {\n      return;\n    }\n    super.build();\n  }\n\n  public detach(): void {\n    super.detach();\n    this.observer.disconnect();\n  }\n\n  public deleteAt(index: number, length: number): void {\n    this.update();\n    if (index === 0 && length === this.length()) {\n      this.children.forEach((child) => {\n        child.remove();\n      });\n    } else {\n      super.deleteAt(index, length);\n    }\n  }\n\n  public formatAt(\n    index: number,\n    length: number,\n    name: string,\n    value: any,\n  ): void {\n    this.update();\n    super.formatAt(index, length, name, value);\n  }\n\n  public insertAt(index: number, value: string, def?: any): void {\n    this.update();\n    super.insertAt(index, value, def);\n  }\n\n  public optimize(context: { [key: string]: any }): void;\n  public optimize(\n    mutations: MutationRecord[],\n    context: { [key: string]: any },\n  ): void;\n  public optimize(mutations: any = [], context: any = {}): void {\n    super.optimize(context);\n    const mutationsMap = context.mutationsMap || new WeakMap();\n    // We must modify mutations directly, cannot make copy and then modify\n    let records = Array.from(this.observer.takeRecords());\n    // Array.push currently seems to be implemented by a non-tail recursive function\n    // so we cannot just mutations.push.apply(mutations, this.observer.takeRecords());\n    while (records.length > 0) {\n      mutations.push(records.pop());\n    }\n    const mark = (blot: Blot | null, markParent = true): void => {\n      if (blot == null || blot === this) {\n        return;\n      }\n      if (blot.domNode.parentNode == null) {\n        return;\n      }\n      if (!mutationsMap.has(blot.domNode)) {\n        mutationsMap.set(blot.domNode, []);\n      }\n      if (markParent) {\n        mark(blot.parent);\n      }\n    };\n    const optimize = (blot: Blot): void => {\n      // Post-order traversal\n      if (!mutationsMap.has(blot.domNode)) {\n        return;\n      }\n      if (blot instanceof ParentBlot) {\n        blot.children.forEach(optimize);\n      }\n      mutationsMap.delete(blot.domNode);\n      blot.optimize(context);\n    };\n    let remaining = mutations;\n    for (let i = 0; remaining.length > 0; i += 1) {\n      if (i >= MAX_OPTIMIZE_ITERATIONS) {\n        throw new Error('[Parchment] Maximum optimize iterations reached');\n      }\n      remaining.forEach((mutation: MutationRecord) => {\n        const blot = this.find(mutation.target, true);\n        if (blot == null) {\n          return;\n        }\n        if (blot.domNode === mutation.target) {\n          if (mutation.type === 'childList') {\n            mark(this.find(mutation.previousSibling, false));\n            Array.from(mutation.addedNodes).forEach((node: Node) => {\n              const child = this.find(node, false);\n              mark(child, false);\n              if (child instanceof ParentBlot) {\n                child.children.forEach((grandChild: Blot) => {\n                  mark(grandChild, false);\n                });\n              }\n            });\n          } else if (mutation.type === 'attributes') {\n            mark(blot.prev);\n          }\n        }\n        mark(blot);\n      });\n      this.children.forEach(optimize);\n      remaining = Array.from(this.observer.takeRecords());\n      records = remaining.slice();\n      while (records.length > 0) {\n        mutations.push(records.pop());\n      }\n    }\n  }\n\n  public update(\n    mutations?: MutationRecord[],\n    context: { [key: string]: any } = {},\n  ): void {\n    mutations = mutations || this.observer.takeRecords();\n    const mutationsMap = new WeakMap();\n    mutations\n      .map((mutation: MutationRecord) => {\n        const blot = this.find(mutation.target, true);\n        if (blot == null) {\n          return null;\n        }\n        if (mutationsMap.has(blot.domNode)) {\n          mutationsMap.get(blot.domNode).push(mutation);\n          return null;\n        } else {\n          mutationsMap.set(blot.domNode, [mutation]);\n          return blot;\n        }\n      })\n      .forEach((blot: Blot | null) => {\n        if (blot != null && blot !== this && mutationsMap.has(blot.domNode)) {\n          blot.update(mutationsMap.get(blot.domNode) || [], context);\n        }\n      });\n    context.mutationsMap = mutationsMap;\n    if (mutationsMap.has(this.domNode)) {\n      super.update(mutationsMap.get(this.domNode), context);\n    }\n    this.optimize(mutations, context);\n  }\n}\n\nexport default ScrollBlot;\n","import Scope from '../scope';\nimport { Blot, Leaf, Root } from './abstract/blot';\nimport LeafBlot from './abstract/leaf';\n\nclass TextBlot extends LeafBlot implements Leaf {\n  public static blotName = 'text';\n  public static scope = Scope.INLINE_BLOT;\n\n  public static create(value: string): Text {\n    return document.createTextNode(value);\n  }\n\n  public static value(domNode: Text): string {\n    return domNode.data;\n  }\n\n  public domNode!: Text;\n  protected text: string;\n\n  constructor(scroll: Root, node: Node) {\n    super(scroll, node);\n    this.text = this.statics.value(this.domNode);\n  }\n\n  public deleteAt(index: number, length: number): void {\n    this.domNode.data = this.text =\n      this.text.slice(0, index) + this.text.slice(index + length);\n  }\n\n  public index(node: Node, offset: number): number {\n    if (this.domNode === node) {\n      return offset;\n    }\n    return -1;\n  }\n\n  public insertAt(index: number, value: string, def?: any): void {\n    if (def == null) {\n      this.text = this.text.slice(0, index) + value + this.text.slice(index);\n      this.domNode.data = this.text;\n    } else {\n      super.insertAt(index, value, def);\n    }\n  }\n\n  public length(): number {\n    return this.text.length;\n  }\n\n  public optimize(context: { [key: string]: any }): void {\n    super.optimize(context);\n    this.text = this.statics.value(this.domNode);\n    if (this.text.length === 0) {\n      this.remove();\n    } else if (this.next instanceof TextBlot && this.next.prev === this) {\n      this.insertAt(this.length(), (this.next as TextBlot).value());\n      this.next.remove();\n    }\n  }\n\n  public position(index: number, _inclusive = false): [Node, number] {\n    return [this.domNode, index];\n  }\n\n  public split(index: number, force = false): Blot | null {\n    if (!force) {\n      if (index === 0) {\n        return this;\n      }\n      if (index === this.length()) {\n        return this.next;\n      }\n    }\n    const after = this.scroll.create(this.domNode.splitText(index));\n    this.parent.insertBefore(after, this.next || undefined);\n    this.text = this.statics.value(this.domNode);\n    return after;\n  }\n\n  public update(\n    mutations: MutationRecord[],\n    _context: { [key: string]: any },\n  ): void {\n    if (\n      mutations.some((mutation) => {\n        return (\n          mutation.type === 'characterData' && mutation.target === this.domNode\n        );\n      })\n    ) {\n      this.text = this.statics.value(this.domNode);\n    }\n  }\n\n  public value(): string {\n    return this.text;\n  }\n}\n\nexport default TextBlot;\n"],"names":["root","factory","exports","module","define","amd","self","window","global","Function","Scope","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","ParchmentError","Error","constructor","message","super","this","name","Registry","attributes","classes","tags","types","static","node","bubble","blots","has","find","parentNode","create","scroll","input","match","query","blotClass","Node","nodeType","TEXT_NODE","blot","set","domNode","scope","Text","text","block","inline","HTMLElement","getAttribute","split","some","tagName","register","definitions","length","map","d","blotName","attrName","keyName","className","Array","isArray","toUpperCase","forEach","tag","WeakMap","ShadowBlot","prev","next","parseInt","toString","document","createElement","indexOf","classList","add","statics","attach","clone","cloneNode","detach","parent","removeChild","deleteAt","index","isolate","remove","formatAt","wrap","format","insertAt","def","ref","insertBefore","undefined","target","offset","children","optimize","_context","requiredContainer","replaceWith","replacement","_force","update","_mutations","wrapper","appendChild","makeAttachedBlot","e","from","childNodes","child","replaceChild","ParentBlot","uiNode","build","other","attachUI","uiClass","setAttribute","firstChild","head","tail","append","nodes","rest","slice","at","iterator","cur","contains","refNode","curNode","ret","inclusive","callback","forEachAt","startNode","curIndex","curLength","Math","min","reduce","memo","push","filter","reverse","err","childLength","descendant","criteria","descendants","Number","MAX_VALUE","lengthLeft","childIndex","concat","enforceAllowedChildren","done","allowedChildren","splitAfter","unwrap","childBlot","refBlot","refDomNode","nextSibling","moveChildren","targetParent","context","defaultChild","path","position","force","after","_length","mutations","addedNodes","removedNodes","mutation","type","body","compareDocumentPosition","DOCUMENT_POSITION_CONTAINED_BY","sort","a","b","DOCUMENT_POSITION_FOLLOWING","ContainerBlot","checkMerge","LeafBlot","_domNode","_inclusive","Attributor","options","attributeBit","whitelist","item","canAdd","_node","replace","removeAttribute","prefix","join","camelize","parts","part","trim","style","attribute","keys","styles","attr","copy","move","values","InlineBlot","toLowerCase","formats","obj1","obj2","isEqual","BlockBlot","_scroll","OBSERVER_CONFIG","characterData","characterDataOldValue","childList","subtree","ScrollBlot","registry","observer","MutationObserver","observe","disconnect","mutationsMap","records","takeRecords","pop","mark","markParent","delete","remaining","i","previousSibling","grandChild","TextBlot","createTextNode","data","splitText"],"sourceRoot":""}